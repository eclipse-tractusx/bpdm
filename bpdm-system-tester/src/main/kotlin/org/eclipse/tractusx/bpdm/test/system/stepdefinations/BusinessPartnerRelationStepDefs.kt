/*******************************************************************************
 * Copyright (c) 2021,2024 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License, Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

package org.eclipse.tractusx.bpdm.test.system.stepdefinations

import io.cucumber.java.en.Given
import io.cucumber.java.en.Then
import io.cucumber.java.en.When
import org.assertj.core.api.Assertions
import org.eclipse.tractusx.bpdm.common.dto.AddressType
import org.eclipse.tractusx.bpdm.gate.api.client.GateClient
import org.eclipse.tractusx.bpdm.gate.api.model.RelationOutputDto
import org.eclipse.tractusx.bpdm.gate.api.model.SharableRelationType
import org.eclipse.tractusx.bpdm.gate.api.model.request.RelationOutputSearchRequest
import org.eclipse.tractusx.bpdm.gate.api.model.request.RelationPutEntry
import org.eclipse.tractusx.bpdm.gate.api.model.request.RelationPutRequest
import org.eclipse.tractusx.bpdm.gate.api.model.response.BusinessPartnerOutputRelationDto
import org.eclipse.tractusx.bpdm.pool.api.client.PoolApiClient
import org.eclipse.tractusx.bpdm.pool.api.model.RelationVerboseDto
import org.eclipse.tractusx.bpdm.test.system.utils.StepUtils
import org.eclipse.tractusx.bpdm.test.testdata.gate.GateInputFactory
import org.eclipse.tractusx.bpdm.test.testdata.gate.withAddressType
import org.eclipse.tractusx.bpdm.test.testdata.gate.withoutAnyBpn
import org.eclipse.tractusx.orchestrator.api.client.OrchestrationApiClient
import org.eclipse.tractusx.orchestrator.api.model.*
import java.time.Instant
import java.time.OffsetDateTime
import java.time.ZoneOffset
import java.util.concurrent.ConcurrentHashMap
import org.eclipse.tractusx.bpdm.gate.api.model.RelationType as GateRelationType
import org.eclipse.tractusx.bpdm.pool.api.model.RelationType as PoolRelationType


class BusinessPartnerRelationStepDefs(
    private val stepUtils: StepUtils,
    private val inputFactory: GateInputFactory,
    private val gateClient: GateClient,
    private val orchestratorClient: OrchestrationApiClient,
    private val poolApiClient: PoolApiClient
): SpringTestRunConfiguration() {

    private val anyTime: Instant = OffsetDateTime.of(2025, 1, 1, 1, 1, 1, 1, ZoneOffset.UTC).toInstant()

    /**
     * Since BPNs are created on-the-fly by the Pool we can't assign a certain BPN directly to a shared record
     * Therefore we associate the BPN tag in the Gherkin description with the BPN after it has been generated
     * In the following Cucumber steps we can then reference the BPN by the BPN tag in the Gherkin description
     */
    val bpnsByTag: ConcurrentHashMap<String, String> = ConcurrentHashMap()

    /**
     * Task-IDs are also generated by the on-the-fly by the golden record process.
     * Additionally, as a refinement service we can't reserve a specific task for processing from the golden record process.
     * Therefore, we just reserve everything and store it for later use by the Cucumber steps here
     */
    val reservedTasksById: ConcurrentHashMap<String, TaskRelationsStepReservationEntryDto> = ConcurrentHashMap()


    /**
     * Creates a business partner of type legal entity in the Gate and shares it with the Pool
     *
     * The created BPNL is stored by the given BPN tag in the Gherkin description
     */
    @Given("shared legal entity with external-ID {string} and BPNL {string}")
    fun `given shared legal entity`(externalId: String, bpnTag: String) {
        val legalEntityInputRequest = inputFactory.createFullValid(externalId, withTestRunContext = false)
            .withAddressType(AddressType.LegalAndSiteMainAddress)
            .withoutAnyBpn()

        gateClient.businessParters.upsertBusinessPartnersInput(listOf(legalEntityInputRequest))
        stepUtils.waitForBusinessPartnerResult(externalId)

        val legalEntityOutput = gateClient.businessParters.getBusinessPartnersOutput(listOf(externalId)).content.single()
        bpnsByTag.put(bpnTag, legalEntityOutput.legalEntity.legalEntityBpn)
    }

    /**
     * A relation is created in the Gate and passed through the refinement step in the golden record process
     *
     * The relation content is not changed in the refinement step
     */
    @When("sharing relation with external-ID {string} of type {string}, source {string} and target {string}")
    fun `when sharing relation`(externalId: String, relationTypeString: String, source: String, target: String) {
        val relationType = GateRelationType.valueOf(relationTypeString)
        val relationInputRequest = RelationPutEntry(externalId, relationType, source, target)

        gateClient.relation.put(true, RelationPutRequest(listOf(relationInputRequest)))
        val taskId = stepUtils.waitForRelationTask(externalId)

        reserveRefinementQueue()
        resolveReservedTask(taskId)

        stepUtils.waitForRelationResult(externalId)
    }

    /**
     * Check whether the Pool's golden record legal entities have the specified relation information
     *
     * Check both legal entities that are referenced in the source and target of the relation
     */
    @Then("Pool has relation of type {string}, source {string} and target {string}")
    fun `then pool has relation`(relationTypeString: String, sourceBpnTag: String, targetBpnTag: String) {
        val relationType = PoolRelationType.valueOf(relationTypeString)
        val sourceBpn = bpnsByTag[sourceBpnTag]!!
        val targetBpn = bpnsByTag[targetBpnTag]!!

        val sourceLegalEntity = poolApiClient.legalEntities.getLegalEntity(sourceBpn)
        val targetLegalEntity = poolApiClient.legalEntities.getLegalEntity(targetBpn)

        val expectedRelation = RelationVerboseDto(relationType, sourceBpn, targetBpn, true)

        val sourceRelations = sourceLegalEntity.legalEntity.relations
        val targetRelations = targetLegalEntity.legalEntity.relations

        Assertions.assertThat(sourceRelations).contains(expectedRelation)
        Assertions.assertThat(targetRelations).contains(expectedRelation)
    }

    /**
     * Check Gate has the specified relation output
     */
    @Then("Gate has relation output with external-ID {string} of type of type {string}, source {string} and target {string}")
    fun `then gate has relation output`(externalId: String, relationTypeString: String, sourceBpnTag: String, targetBpnTag: String) {
        val relationType = SharableRelationType.valueOf(relationTypeString)
        val sourceBpn = bpnsByTag[sourceBpnTag]!!
        val targetBpn = bpnsByTag[targetBpnTag]!!

        val relationOutput = gateClient.relationOutput.postSearch(RelationOutputSearchRequest(externalIds = listOf(externalId))).content.single()

        val expectedRelation = RelationOutputDto(externalId, relationType, sourceBpn, targetBpn, anyTime)

        Assertions.assertThat(relationOutput)
            .usingRecursiveComparison()
            .ignoringFields(RelationOutputDto::updatedAt.name)
            .isEqualTo(expectedRelation)
    }

    /**
     * Check Gate has business partner output with the specified relation information
     */
    @Then("Gate has business partner output with external-ID {string} with relation of type {string}, source {string} and target {string}")
    fun `then gate has business partner output with relation`(externalId: String, relationTypeString: String, sourceBpnTag: String, targetBpnTag: String) {
        val businessPartnerOutput = stepUtils.waitForOutputRelation(externalId)

        val relationType = SharableRelationType.valueOf(relationTypeString)
        val sourceBpn = bpnsByTag[sourceBpnTag]!!
        val targetBpn = bpnsByTag[targetBpnTag]!!
        val expectedRelation = BusinessPartnerOutputRelationDto(relationType, sourceBpn, targetBpn)

        Assertions.assertThat(businessPartnerOutput.legalEntity.relations)
                .contains(expectedRelation)
    }

    /**
     * Reserve all tasks in queue up to this point in time and store the reserved tasks for later use
     */
    private fun reserveRefinementQueue(){
        var reservedTasks: List<TaskRelationsStepReservationEntryDto> = emptyList()
        do{
            reservedTasks = orchestratorClient.relationsGoldenRecordTasks.reserveTasksForStep(TaskStepReservationRequest(100, TaskStep.CleanAndSync)).reservedTasks
            reservedTasks.forEach { reservedTasksById.put(it.taskId, it) }
        }while (reservedTasks.isNotEmpty())
    }

    /**
     * Resolves without changing the relation content
     */
    private fun resolveReservedTask(taskId: String){
        val reservedTask = reservedTasksById[taskId]

        val refinementResult = TaskRelationsStepResultEntryDto(reservedTask!!.taskId, reservedTask.businessPartnerRelations, emptyList())
        orchestratorClient.relationsGoldenRecordTasks.resolveStepResults(TaskRelationsStepResultRequest(TaskStep.CleanAndSync, listOf(refinementResult)))
    }

}